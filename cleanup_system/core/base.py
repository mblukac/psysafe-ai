"""Base interface for all cleanup modules."""

from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from pathlib import Path
from typing import Any, Dict, List, Optional, Set


class CleanupPhase(Enum):
    """Enumeration of cleanup phases."""
    
    DEAD_CODE_REMOVAL = "dead_code_removal"
    DOCUMENTATION_REFRESH = "documentation_refresh"
    CODE_CONSOLIDATION = "code_consolidation"
    STANDARDS_ENFORCEMENT = "standards_enforcement"
    DEPENDENCY_CLEANUP = "dependency_cleanup"
    TEST_VALIDATION = "test_validation"
    VERSION_CONTROL = "version_control"


@dataclass
class FileChange:
    """Represents a change to a file."""
    
    file_path: Path
    change_type: str  # 'modified', 'deleted', 'created'
    description: str
    line_changes: Dict[str, Any] = field(default_factory=dict)
    
    def __str__(self) -> str:
        return f"{self.change_type.upper()}: {self.file_path} - {self.description}"


@dataclass
class CleanupReport:
    """Report generated by a cleanup operation."""
    
    phase: CleanupPhase
    start_time: datetime
    end_time: Optional[datetime] = None
    files_modified: List[FileChange] = field(default_factory=list)
    errors: List[str] = field(default_factory=list)
    warnings: List[str] = field(default_factory=list)
    metrics: Dict[str, Any] = field(default_factory=dict)
    success: bool = True
    
    def add_file_change(self, change: FileChange) -> None:
        """Add a file change to the report."""
        self.files_modified.append(change)
    
    def add_error(self, error: str) -> None:
        """Add an error to the report."""
        self.errors.append(error)
        self.success = False
    
    def add_warning(self, warning: str) -> None:
        """Add a warning to the report."""
        self.warnings.append(warning)
    
    def add_metric(self, key: str, value: Any) -> None:
        """Add a metric to the report."""
        self.metrics[key] = value
    
    def finalize(self) -> None:
        """Finalize the report with end time."""
        self.end_time = datetime.now()
        if self.errors:
            self.success = False
    
    def get_summary(self) -> str:
        """Get a summary of the cleanup report."""
        duration = (self.end_time - self.start_time).total_seconds() if self.end_time else 0
        return (
            f"Phase: {self.phase.value}\n"
            f"Duration: {duration:.2f}s\n"
            f"Files Modified: {len(self.files_modified)}\n"
            f"Errors: {len(self.errors)}\n"
            f"Warnings: {len(self.warnings)}\n"
            f"Success: {self.success}"
        )


class CodeCleanupBase(ABC):
    """Base interface for all code cleanup modules."""
    
    def __init__(self, project_root: Path, config: Optional[Dict[str, Any]] = None):
        """
        Initialize the cleanup module.
        
        Args:
            project_root: Root directory of the project
            config: Optional configuration dictionary
        """
        self.project_root = project_root
        self.config = config or {}
        self._excluded_paths: Set[Path] = set()
        self._initialize_exclusions()
    
    def _initialize_exclusions(self) -> None:
        """Initialize default path exclusions."""
        default_exclusions = [
            ".git", "__pycache__", ".pytest_cache", ".mypy_cache",
            "*.egg-info", ".venv", "venv", "env", ".env",
            "node_modules", "dist", "build", ".coverage",
            "cleanup_system"  # Exclude the cleanup system itself
        ]
        
        for pattern in default_exclusions:
            self._excluded_paths.add(pattern)
        
        # Add custom exclusions from config
        custom_exclusions = self.config.get("exclude_paths", [])
        self._excluded_paths.update(custom_exclusions)
    
    def should_process_file(self, file_path: Path) -> bool:
        """
        Check if a file should be processed.
        
        Args:
            file_path: Path to check
            
        Returns:
            True if the file should be processed
        """
        # Check if file is in excluded paths
        for exclusion in self._excluded_paths:
            if exclusion in str(file_path):
                return False
        
        # Only process Python files by default
        if not str(file_path).endswith('.py'):
            return False
        
        return True
    
    def get_python_files(self) -> List[Path]:
        """
        Get all Python files in the project.
        
        Returns:
            List of Python file paths
        """
        python_files = []
        
        for file_path in self.project_root.rglob("*.py"):
            if self.should_process_file(file_path):
                python_files.append(file_path)
        
        return sorted(python_files)
    
    @abstractmethod
    def analyze(self) -> Dict[str, Any]:
        """
        Analyze the codebase for potential cleanup opportunities.
        
        Returns:
            Dictionary containing analysis results
        """
        pass
    
    @abstractmethod
    def execute(self, dry_run: bool = False) -> CleanupReport:
        """
        Execute the cleanup operation.
        
        Args:
            dry_run: If True, only simulate changes without applying them
            
        Returns:
            CleanupReport containing results of the operation
        """
        pass
    
    @abstractmethod
    def validate(self) -> bool:
        """
        Validate that the cleanup can be safely performed.
        
        Returns:
            True if validation passes
        """
        pass
    
    def get_phase(self) -> CleanupPhase:
        """
        Get the cleanup phase this module handles.
        
        Returns:
            The cleanup phase
        """
        # Default implementation - subclasses should override
        return CleanupPhase.DEAD_CODE_REMOVAL